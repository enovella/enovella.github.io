---
layout: post
title:  "CVE-2015-0558: Reverse-engineering the default WPA key generation algorithm for Pirelli routers in Argentina"
date:   2017-08-20 03:59:03 +0700
categories: [mips, reverse, routers, wireless]
---

<div style="width: 200px;text-align:center;" markdown="1">
![10](https://raw.githubusercontent.com/enovella/enovella.github.io/master/static/img/_posts/arnetrouter.jpg "sticker")
{:.image-caption}
*Sticker with default settings*
</div>

A couple of years ago whether I do not remember badly, I was doing reverse engineering in some Spanish routers deployed by Pirelli as well. After I extracted the firmware and found out a suspicious library with many references to key generation’s functions everything was over. Unfortunately, I could not recover the algorithm itself. Principally, because those routers were not using the same algorithm  for generating default keys and simply because such algorithm was not explicitly there. Shit happens!  However, as I could not reveal the algorithm then decided to try another way to recover keys. Eventually, I realized that these routers were vulnerable to unauthorized and unauthenticated remote access and any adversary could fetch HTML code from our public IP address. Plenty of HTMLs were able to be downloaded without any restriction, meaning a huge leakage. Being vulnerable to a bunch of evil attacks. This  remote information disclosure can be seen on this CVE-2015-0554. On the other side, I do not know whether Argentinian routers are also vulnerable to this vulnerability. Feel free to try it out and let me know too.
Just to see how easy was to achieve those keys in the HomeStation(essids-like WLAN_XXXX)  in Spain, a simple curl command was enough:

```sh
$ curl -s http://${IP_ADDRESS}/wlsecurity.html | grep -i "WLAN_"
                  <option value='0'>WLAN_DEAD</option>

$ curl -s http://${IP_ADDRESS}/wlsecurity.html | grep -i "var wpapskkey"
var wpaPskKey = 'IsAklFHhFFui1sr9ZMqD';

$ curl -s http://${IP_ADDRESS}/wlsecurity.html | grep -i "var WscDevPin"
var WscDevPin    = '12820078';
```

Now, I am gonna explain how I reverse engineered a MIPS library in order to recover the default WPA key generation algorithm for some Argentinian routers deployed by Pirelli. Concretely the router affected is the model P.DG-A4001N.  First of all, I am neither Argentinian nor live there. Nevertheless, accidentally  I observed some stickers from Pirelli routers in a random forum and as an user had already publicly published the firmware for those routers then I decided to give a try.  As I still remembered the file which I dug into for the Spanish routers, I rapidly tried to recover the algorithm in these routers. The writing below is the way I followed until achieved it.

### Reverse-engineering the default key generation algorithm

In this section, we are going to reverse engineer a MIPS library, ```/lib/private/libcms.core```,  found out in the firmware itself.  First of all, let us comment that the firmware was physically extracted for another user (fernando3k) and subsequently unpacked using ```Binwalk``` and firmware-mod-kit by me. Once was mounted into our system, we found out a function called ```generatekey```. As you have seen,  symbols have not been removed in binaries and external function names are still there because dynamic compilation. This help us a lot in our reverse engineering task.  On top of that, we rapidly saw how this function was calling to another one called ```generatekey_from_mac```. At this moment, I decided to give a go to this challenge. Before get started, IDA Pro can help us with the cross references (Xrefs to-from in IDA Pro) between functions. Let’s see how functions are called in the library. (Zoom pictures in to see properly).

<div style="text-align:center" markdown="1">
![0](https://raw.githubusercontent.com/enovella/enovella.github.io/master/static/img/_posts/00_generateKey.png "generateKey")
{:.image-caption}
*Call flow from generateKey*
</div>

Really looking great! Now let’s look at the cross references. We have figured out some tips:

- ```generatekey``` calls ```generatekey_from_mac```.  This allow us to suppose that the mac address is involved in the key generation algorithm. Besides, ```getPBSHwaddr``` returns a mac address and it is also called by ```generatekey```. Verification was carried out after checking how getPBSHwaddr returned the value of ```/var/hwaddr``` ( ```ifconfig %s > /var/hwaddr```)
- SHA256 cryptographic hash function is also involved. We then know that our key is coming from a well-known hash function. This way to generate WPA keys is very popular in some vendors because the feeling of “randomness”. Digging into this function will give us the main structure of our algorithm.
- The function ```createWPAPassphraseFromKey``` is called by ```wlWriteMdmDefault```, which also calls to ```generatekey``` as well. Hence, we discover a function called ```bintoascii```, which is basically responsible to convert binary to ascii data.
- The SSID is also created from the mac address although it is not relevant for our task.

<div style="text-align:center" markdown="1">
![1](https://raw.githubusercontent.com/enovella/enovella.github.io/master/static/img/_posts/01_createWPAPassphraseFromKey.png "createWPAPassphraseFromKey")
{:.image-caption}
*Call flow for createWPAPassphraseFromKey*
</div>

Now we must dissect the ```generatekey_from_mac``` function and its SHA256 callings to figure out how many parameters are being sent as input data. Before calling ```generatekey```, a string ```1236790``` is sent to this function as first argument (```$a3```).  Nonetheless, we have to guess which is the right order for the SHA256 function, I mean how many updates there are. If we observe the below picture, we will see this step.


<div style="text-align:center" markdown="1">
![2](https://raw.githubusercontent.com/enovella/enovella.github.io/master/static/img/_posts/02_wlWriteMdmDefault.png "wlWriteMdmDefault")
{:.image-caption}
*Disassembly of wlWriteMdmDefault*
</div>

From ```generateKey_from_mac``` we realize that: (Look at image below)
- First argument is located at offset ```0x000d29e0```
- Second argument is the string we discovered previously (```1236790```)
- Third argument it has to be the mac address because there is an instruction load immediate with the value  6. Since a mac address is 6 bytes, we can try it out now.

<div style="text-align:center" markdown="1">
![3](https://raw.githubusercontent.com/enovella/enovella.github.io/master/static/img/_posts/03_generateKey_from_mac.png "generateKey_from_mac")
{:.image-caption}
*Disassembly of generateKey_from_mac*
</div>

As we know that the first argument is located at the offset ```0xd29e0```, just a jump there and let’s reveal the secret seed used in the SHA256.  Now we have guessed the first argument, and we can prepare those 32 bytes into a byte-array structure to generate the  SHA256 hash later on. This secret seed has been used by Pirelli too in other countries like Italy or Austria (Look at the references on the source code for more info). Furthermore, below that we can also distinguish the charset finally used to generate keys with.

<div style="text-align:center" markdown="1">
![4](https://raw.githubusercontent.com/enovella/enovella.github.io/master/static/img/_posts/04_secretSeed.png "Secret Seed")
{:.image-caption}
*Secret data found out in the library.*
</div>

In the end, we conclude that the algorithm is as follows: (mac address needs to be incremented by 1)

*SHA256(secret_seed + "1236790" + mac_address)*

More details on how keys are eventually generated  in this python function:

```python
def genkey(mac):
    seed = ('\x64\xC6\xDD\xE3\xE5\x79\xB6\xD9\x86\x96\x8D\x34\x45\xD2\x3B\x15' +
            '\xCA\xAF\x12\x84\x02\xAC\x56\x00\x05\xCE\x20\x75\x91\x3F\xDC\xE8')

    lookup  = '0123456789abcdefghijklmnopqrstuvwxyz'

    sha256 = hashlib.sha256()
    sha256.update(seed)
    sha256.update('1236790')
    sha256.update(mac)

    digest = bytearray(sha256.digest())

    return ''.join([lookup[x % len(lookup)] for x in digest[0:10]])
```

# Problems

Since I attempted to do a responsible disclosure and neither ADB Pirelli nor Arnet Argentina were interested to discuss the problem, I have finally decided to do full disclosure to speed up the process of fixing. It looks like the only way with some vendors, just enforce them to replace routers for avoiding intrusions. Many things can happen whether your router with SSID Wifi-Arnet-XXXX has the default password. For your information, default passwords are located in a sticker at the bottom of routers. If you are owner of these networks, please change your password as soon as possible. You should always change the default passwords, though.
An adversary, within of the wifi range,  could access to your network and commit any sort of fraud. Be safe and change the passwords right now!


# Timeline

* 2014-09-11  Found the algorithm
* 2014-09-12  Send a message to @ArnetOnline via Twitter @enovella_
* 2014-09-15  Send a message via website, still looking for a simple mail
* 2014-09-16  Send another message to Arnet via website.First reply via twitter where they redirect me to the website form.
* 2014-09-19  Direct message via twitter. I talk with them about the critical vulnerability and offer them an email with PGP key
* 2014-09-20  More twitter PM about the same. They do not want to be aware about the problem though.
* 2014-09-23  I assume that Arnet does not care about its clients’ security at all regarding its little interest.
* 2014-09-24  I send the problem to the vendor ADB Pirelli via website form
* 2014-09-28  I send the problem to the vendor ADB Pirelli via email to Switzerland
* 2015-01-05  Full disclosure

# Proof-of-concept

This proof-of-concept and many Pirelli default key generation algorithms might be found at my Bitbucket repository. To be installed just make sure you got git installed on your system and then run:

```sh
$ git clone https://dudux@bitbucket.org/dudux/adbpirelli.git
$ cd adbpirelli && chmod +x *.py
$ python wifiarnet.py
```
